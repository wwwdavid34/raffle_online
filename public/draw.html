<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-67MVYE0NVR"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-67MVYE0NVR');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Raffle - Draw</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
    body.projector-mode {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }
    body.projector-mode #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    body.projector-mode .view.active {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      width: 100%;
      padding: 1rem;
      box-sizing: border-box;
    }
    body.projector-mode .card {
      margin: 0 auto;
      width: 100%;
      max-width: min(90vw, 800px);
      max-height: 90vh;
      overflow: auto;
    }
    body.projector-mode .session-header {
      padding: clamp(0.5rem, 2vh, 2rem);
      text-align: center;
      flex-shrink: 0;
      width: 100%;
    }
    body.projector-mode .session-event-name {
      font-size: clamp(1.5rem, 4vw, 3rem) !important;
      width: 100%;
    }
    /* Winner state - full screen reactive */
    body.projector-mode #winnerState {
      max-width: 95vw;
      max-height: 95vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-bottom: clamp(1.5rem, 4vh, 3rem);
    }
    body.projector-mode #winnerState .winner-actions {
      margin-bottom: clamp(0.5rem, 2vh, 1.5rem);
    }
    body.projector-mode #winnerState .winner-display {
      padding: clamp(1rem, 4vh, 3rem);
    }
    body.projector-mode #winnerState .winner-title {
      font-size: clamp(2rem, 6vw, 5rem);
    }
    body.projector-mode #winnerState .winner-ticket {
      font-size: clamp(3rem, 10vw, 8rem);
    }
    body.projector-mode #winnerState .winner-batch {
      font-size: clamp(1rem, 2.5vw, 2rem);
    }
    body.projector-mode #winnerState .winner-label {
      font-size: clamp(1.25rem, 3vw, 2.5rem);
    }
    body.projector-mode #winnerState .countdown {
      font-size: clamp(3rem, 8vw, 6rem);
    }
    body.projector-mode #winnerState .text-large {
      font-size: clamp(1rem, 2.5vw, 2rem);
    }
    /* Stats grid reactive */
    body.projector-mode .stats-grid {
      gap: clamp(0.5rem, 2vw, 1.5rem);
    }
    body.projector-mode .stat-value {
      font-size: clamp(2rem, 6vw, 4rem);
    }
    body.projector-mode .stat-label {
      font-size: clamp(0.75rem, 1.5vw, 1.25rem);
    }
    /* Buttons reactive */
    body.projector-mode .btn {
      font-size: clamp(1rem, 2vw, 1.5rem);
      padding: clamp(0.75rem, 2vh, 1.5rem) clamp(1rem, 3vw, 2rem);
    }
    body.projector-mode #drawBtn {
      font-size: clamp(1.5rem, 3vw, 2.5rem) !important;
      padding: clamp(1rem, 3vh, 2rem) clamp(1.5rem, 4vw, 3rem) !important;
    }
    /* Drawing animation reactive */
    body.projector-mode .drawing-animation {
      font-size: clamp(4rem, 12vw, 10rem);
    }
    body.projector-mode .drawing-text {
      font-size: clamp(1.5rem, 3vw, 2.5rem);
    }
    /* Main view layout */
    body.projector-mode #mainView {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
    }
    body.projector-mode #mainView > .card {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .winner-actions {
      transition: opacity 0.3s ease-out;
    }
    .winner-actions.auto-hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body class="projector-mode">
  <div id="app">
    <!-- Session Code Entry View (when no session ID in URL) -->
    <div id="codeView" class="view active">
      <h1 data-i18n="handout.enterPin">Enter Session Code</h1>
      <div id="codeError" class="error-message hidden"></div>

      <div class="card" style="max-width: 400px; margin: 0 auto;">
        <div class="pin-input-container" id="codeInputSection">
          <input type="text" class="pin-input code-input" maxlength="1" inputmode="numeric" data-index="0">
          <input type="text" class="pin-input code-input" maxlength="1" inputmode="numeric" data-index="1">
          <input type="text" class="pin-input code-input" maxlength="1" inputmode="numeric" data-index="2">
          <input type="text" class="pin-input code-input" maxlength="1" inputmode="numeric" data-index="3">
          <input type="text" class="pin-input code-input" maxlength="1" inputmode="numeric" data-index="4">
          <input type="text" class="pin-input code-input" maxlength="1" inputmode="numeric" data-index="5">
        </div>
      </div>
    </div>

    <!-- Passcode Entry View (when session requires authentication) -->
    <div id="passcodeView" class="view">
      <h1 data-i18n="control.enterPasscode">Enter Passcode</h1>
      <div id="passcodeError" class="error-message hidden"></div>

      <div class="card" style="max-width: 400px; margin: 0 auto;">
        <p class="text-center text-secondary mb-2" data-i18n="control.passcodeRequired">This session requires a passcode</p>
        <div class="pin-input-container" id="passcodeInputSection">
          <input type="text" class="pin-input passcode-input" maxlength="1" inputmode="numeric" data-index="0">
          <input type="text" class="pin-input passcode-input" maxlength="1" inputmode="numeric" data-index="1">
          <input type="text" class="pin-input passcode-input" maxlength="1" inputmode="numeric" data-index="2">
          <input type="text" class="pin-input passcode-input" maxlength="1" inputmode="numeric" data-index="3">
        </div>
      </div>
    </div>

    <!-- Main Draw View -->
    <div id="mainView" class="view">
      <div class="session-header">
        <div class="session-event-name" id="eventName" style="font-size: 2rem;"></div>
      </div>

      <div id="error" class="error-message hidden"></div>

      <!-- Open State - Registration in progress -->
      <div id="openState" class="card hidden">
        <h2 class="text-center" data-i18n="draw.registrationOpen">Registration is open</h2>

        <div class="stats-grid mt-3">
          <div class="stat-card">
            <div class="stat-value" id="openTotalTickets">0</div>
            <div class="stat-label" data-i18n="draw.ticketCount">Total Tickets</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="openAvailableTickets">0</div>
            <div class="stat-label" data-i18n="draw.availableTickets">Available</div>
          </div>
        </div>

        <button type="button" id="lockBtn" class="btn btn-warning mt-3">
          <span data-i18n="draw.lockRegistration">Lock Registration</span>
        </button>
      </div>

      <!-- Locked State - Ready to draw -->
      <div id="lockedState" class="card hidden">
        <h2 class="text-center" data-i18n="draw.waitingToDraw">Ready to draw</h2>

        <div class="stats-grid mt-3">
          <div class="stat-card">
            <div class="stat-value" id="lockedTotalTickets">0</div>
            <div class="stat-label" data-i18n="draw.ticketCount">Total Tickets</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="lockedAvailableTickets">0</div>
            <div class="stat-label" data-i18n="draw.availableTickets">Available</div>
          </div>
        </div>

        <button type="button" id="drawBtn" class="btn btn-success mt-3" style="font-size: 1.5rem; padding: 1.5rem;">
          <span data-i18n="draw.startDraw">Draw Winner</span>
        </button>

        <div class="action-grid mt-2">
          <button type="button" id="reopenBtn" class="btn btn-warning">
            <span data-i18n="draw.reopen">Reopen Registration</span>
          </button>
          <button type="button" id="closeSessionBtn" class="btn btn-secondary">
            <span data-i18n="draw.closeSession">End Raffle</span>
          </button>
        </div>
      </div>

      <!-- Drawing Animation -->
      <div id="drawingState" class="card hidden">
        <div class="drawing-container">
          <div class="drawing-animation" id="drawingAnimation">????</div>
          <p class="drawing-text" data-i18n="session.state.drawing">Drawing...</p>
        </div>
      </div>
      <div id="drumRollOverlay" class="drum-roll-overlay hidden"></div>

      <!-- Confetti Container -->
      <div id="confettiContainer" class="confetti-container"></div>

      <!-- Winner Display -->
      <div id="winnerState" class="card hidden">
        <div class="winner-display" id="winnerDisplay">
          <div class="winner-title" data-i18n="draw.winner">WINNER</div>
          <div class="winner-batch">
            <span data-i18n="draw.batch">Batch</span> <span id="winnerBatchId"></span>
          </div>
          <div class="winner-ticket" id="winnerTicketId"></div>
          <div class="winner-label" id="winnerLabel"></div>
        </div>

        <div class="text-center mt-2">
          <p class="text-large" data-i18n="draw.claimNow">Please come forward to claim your prize!</p>
        </div>

        <div class="countdown mt-3" id="countdown">60</div>
        <p class="text-center text-secondary" data-i18n="draw.timeRemaining">Time remaining</p>

        <div class="action-grid mt-3 winner-actions" id="winnerActions">
          <button type="button" id="redrawBtn" class="btn btn-warning">
            <span data-i18n="draw.redraw">Redraw</span>
          </button>
          <button type="button" id="confirmClaimBtn" class="btn btn-success">
            <span data-i18n="draw.confirmClaim">Confirm Claim</span>
          </button>
        </div>
      </div>

      <!-- Closed State -->
      <div id="closedState" class="card hidden">
        <h1 class="text-center" data-i18n="thanks.title">Thank You!</h1>
        <p class="text-center text-secondary mt-2" data-i18n="thanks.message">
          Thank you for participating in this raffle.
        </p>
      </div>
    </div>
  </div>

  <script src="/i18n.js"></script>
  <script>
    // Get session ID from URL: /s/{sessionId}/draw or /draw
    const pathParts = window.location.pathname.split('/');
    let currentSessionId = null;

    // Check if URL has session ID: /s/{id}/draw
    if (pathParts[1] === 's' && pathParts[2]) {
      currentSessionId = pathParts[2];
    }

    let sessionData = null;
    let countdownInterval = null;
    let pollInterval = null;
    let currentWinnerTicketId = null;
    let storedPasscode = null;

    // DOM Elements
    const codeView = document.getElementById('codeView');
    const passcodeView = document.getElementById('passcodeView');
    const mainView = document.getElementById('mainView');
    const codeInputs = document.querySelectorAll('.code-input');
    const passcodeInputs = document.querySelectorAll('.passcode-input');
    const codeError = document.getElementById('codeError');
    const passcodeError = document.getElementById('passcodeError');
    const errorDiv = document.getElementById('error');

    // State views
    const openState = document.getElementById('openState');
    const lockedState = document.getElementById('lockedState');
    const drawingState = document.getElementById('drawingState');
    const winnerState = document.getElementById('winnerState');
    const closedState = document.getElementById('closedState');

    // Initialize
    init();

    async function init() {
      if (currentSessionId) {
        // Session ID in URL - load session and check if passcode required
        try {
          const response = await fetch(`/api/session/${currentSessionId}`);
          if (!response.ok) {
            throw new Error('Session not found');
          }
          sessionData = await response.json();
          setLanguage(sessionData.language);

          // Apply theme
          if (sessionData.theme && sessionData.theme !== 'default') {
            document.documentElement.setAttribute('data-theme', sessionData.theme);
          }

          document.getElementById('eventName').textContent = sessionData.eventName;
          document.title = `${sessionData.eventName} - Draw`;

          // Check if passcode is required
          if (sessionData.hasPasscode) {
            showView('passcode');
            setupPasscodeInputs();
          } else {
            // No passcode required - go directly to main view
            showView('main');
            updateState();
            startPolling();
          }
        } catch (err) {
          showError(err.message);
        }
      } else {
        // No session ID - show code entry
        showView('code');
        setupCodeInputs();
      }

      setupButtons();
    }

    function showView(view) {
      codeView.classList.remove('active');
      passcodeView.classList.remove('active');
      mainView.classList.remove('active');

      switch (view) {
        case 'code':
          codeView.classList.add('active');
          break;
        case 'passcode':
          passcodeView.classList.add('active');
          break;
        case 'main':
          mainView.classList.add('active');
          break;
      }
    }

    function showState(state) {
      openState.classList.add('hidden');
      lockedState.classList.add('hidden');
      drawingState.classList.add('hidden');
      winnerState.classList.add('hidden');
      closedState.classList.add('hidden');

      switch (state) {
        case 'OPEN':
          openState.classList.remove('hidden');
          break;
        case 'LOCKED':
          lockedState.classList.remove('hidden');
          break;
        case 'DRAWING':
          if (sessionData.currentWinner) {
            showWinner(sessionData.currentWinner);
          } else {
            drawingState.classList.remove('hidden');
          }
          break;
        case 'CLOSED':
          closedState.classList.remove('hidden');
          break;
      }
    }

    function setupCodeInputs() {
      codeInputs.forEach((input, index) => {
        input.addEventListener('input', (e) => {
          const value = e.target.value.replace(/\D/g, '');
          e.target.value = value;

          if (value && index < codeInputs.length - 1) {
            codeInputs[index + 1].focus();
          }

          const code = Array.from(codeInputs).map(i => i.value).join('');
          if (code.length === 6) {
            verifySessionCode(code);
          }
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Backspace' && !e.target.value && index > 0) {
            codeInputs[index - 1].focus();
          }
        });

        input.addEventListener('paste', (e) => {
          e.preventDefault();
          const paste = (e.clipboardData || window.clipboardData).getData('text');
          const digits = paste.replace(/\D/g, '').slice(0, 6);
          digits.split('').forEach((digit, i) => {
            if (codeInputs[i]) codeInputs[i].value = digit;
          });
          if (digits.length === 6) verifySessionCode(digits);
        });
      });

      codeInputs[0].focus();
    }

    async function verifySessionCode(code) {
      try {
        // Verify session exists
        const checkResponse = await fetch(`/api/session/${code}`);
        if (!checkResponse.ok) {
          throw new Error(t('error.sessionNotFound'));
        }
        // Session exists, redirect to the proper URL
        window.location.href = `/s/${code}/draw`;
      } catch (err) {
        codeError.textContent = err.message;
        codeError.classList.remove('hidden');
        codeInputs.forEach(i => i.value = '');
        codeInputs[0].focus();
      }
    }

    function setupPasscodeInputs() {
      passcodeInputs.forEach((input, index) => {
        input.addEventListener('input', (e) => {
          const value = e.target.value.replace(/\D/g, '');
          e.target.value = value;

          if (value && index < passcodeInputs.length - 1) {
            passcodeInputs[index + 1].focus();
          }

          const passcode = Array.from(passcodeInputs).map(i => i.value).join('');
          if (passcode.length === 4) {
            verifyPasscode(passcode);
          }
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Backspace' && !e.target.value && index > 0) {
            passcodeInputs[index - 1].focus();
          }
        });

        input.addEventListener('paste', (e) => {
          e.preventDefault();
          const paste = (e.clipboardData || window.clipboardData).getData('text');
          const digits = paste.replace(/\D/g, '').slice(0, 4);
          digits.split('').forEach((digit, i) => {
            if (passcodeInputs[i]) passcodeInputs[i].value = digit;
          });
          if (digits.length === 4) verifyPasscode(digits);
        });
      });

      passcodeInputs[0].focus();
    }

    async function verifyPasscode(passcode) {
      try {
        const response = await fetch(`/api/session/${currentSessionId}/verify-passcode`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode })
        });

        const data = await response.json();

        if (data.valid) {
          storedPasscode = passcode;
          showView('main');
          updateState();
          startPolling();
        } else {
          passcodeError.textContent = t('error.invalidPasscode');
          passcodeError.classList.remove('hidden');
          passcodeInputs.forEach(i => i.value = '');
          passcodeInputs[0].focus();
        }
      } catch (err) {
        passcodeError.textContent = err.message;
        passcodeError.classList.remove('hidden');
        passcodeInputs.forEach(i => i.value = '');
        passcodeInputs[0].focus();
      }
    }

    function setupButtons() {
      document.getElementById('lockBtn').addEventListener('click', lockRegistration);
      document.getElementById('reopenBtn').addEventListener('click', reopenRegistration);
      document.getElementById('drawBtn').addEventListener('click', drawWinner);
      document.getElementById('redrawBtn').addEventListener('click', redraw);
      document.getElementById('confirmClaimBtn').addEventListener('click', confirmClaim);
      document.getElementById('closeSessionBtn').addEventListener('click', closeSession);
    }

    function updateStats() {
      // Update open state stats
      document.getElementById('openTotalTickets').textContent = sessionData.ticketCount || 0;
      document.getElementById('openAvailableTickets').textContent = sessionData.availableTickets || 0;

      // Update locked state stats
      document.getElementById('lockedTotalTickets').textContent = sessionData.ticketCount || 0;
      document.getElementById('lockedAvailableTickets').textContent = sessionData.availableTickets || 0;

      // Disable draw if no tickets
      document.getElementById('drawBtn').disabled = (sessionData.availableTickets || 0) === 0;
    }

    function updateState() {
      updateStats();
      showState(sessionData.state);
    }

    function startPolling() {
      pollInterval = setInterval(async () => {
        try {
          const response = await fetch(`/api/session/${currentSessionId}`);
          if (!response.ok) return;

          sessionData = await response.json();
          updateState();
        } catch (err) {
          console.error('Poll error:', err);
        }
      }, 2000);
    }

    async function lockRegistration() {
      const btn = document.getElementById('lockBtn');
      btn.disabled = true;

      try {
        const response = await fetch(`/api/session/${currentSessionId}/lock`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode: storedPasscode })
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to lock');
        }

        sessionData.state = 'LOCKED';
        updateState();
      } catch (err) {
        showError(err.message);
      } finally {
        btn.disabled = false;
      }
    }

    async function reopenRegistration() {
      const btn = document.getElementById('reopenBtn');
      btn.disabled = true;

      try {
        const response = await fetch(`/api/session/${currentSessionId}/reopen`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode: storedPasscode })
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to reopen');
        }

        sessionData.state = 'OPEN';
        updateState();
      } catch (err) {
        showError(err.message);
      } finally {
        btn.disabled = false;
      }
    }

    async function drawWinner() {
      const btn = document.getElementById('drawBtn');
      btn.disabled = true;

      // Show drawing animation with drum roll
      showState('DRAWING');
      document.getElementById('drumRollOverlay').classList.remove('hidden');

      let winnerData = null;

      try {
        // Start the animation immediately
        playDrawingAnimation();

        // Fetch winner in parallel
        const response = await fetch(`/api/session/${currentSessionId}/draw`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode: storedPasscode })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to draw');
        }

        winnerData = data;

        // Continue animation for dramatic effect (total ~4 seconds)
        // Phase 1: Fast spinning (already running for ~1s by now)
        await sleep(1500);

        // Phase 2: Slow down
        slowDownAnimation(winnerData.ticketId);
        await sleep(1500);

        // Phase 3: Final reveal
        stopDrawingAnimation();
        document.getElementById('drumRollOverlay').classList.add('hidden');
        showWinner(winnerData);
        launchConfetti();

      } catch (err) {
        stopDrawingAnimation();
        document.getElementById('drumRollOverlay').classList.add('hidden');
        showState('LOCKED');
        showError(err.message);
        btn.disabled = false;
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function playDrawingAnimation() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      const animEl = document.getElementById('drawingAnimation');
      animEl.classList.remove('slowing', 'stopping');

      let speed = 50;
      function tick() {
        let rand = '';
        for (let i = 0; i < 4; i++) {
          rand += chars[Math.floor(Math.random() * chars.length)];
        }
        animEl.textContent = rand;
        drawingState.dataset.timeout = setTimeout(tick, speed);
      }
      tick();
    }

    function slowDownAnimation(finalTicketId) {
      const animEl = document.getElementById('drawingAnimation');
      animEl.classList.add('slowing');

      // Clear existing animation
      if (drawingState.dataset.timeout) {
        clearTimeout(parseInt(drawingState.dataset.timeout));
      }

      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      const batchId = finalTicketId.split('-')[0];
      let speed = 100;
      let iteration = 0;
      const maxIterations = 15;

      function slowTick() {
        iteration++;
        speed += 30; // Gradually slow down

        let rand = '';
        // As we get closer to the end, lock in more characters
        const lockChars = Math.floor((iteration / maxIterations) * 4);
        for (let i = 0; i < 4; i++) {
          if (i < lockChars) {
            rand += batchId[i] || chars[Math.floor(Math.random() * chars.length)];
          } else {
            rand += chars[Math.floor(Math.random() * chars.length)];
          }
        }
        animEl.textContent = rand;

        if (iteration < maxIterations) {
          drawingState.dataset.timeout = setTimeout(slowTick, speed);
        } else {
          animEl.classList.add('stopping');
          animEl.textContent = batchId;
        }
      }
      slowTick();
    }

    function stopDrawingAnimation() {
      const timeout = drawingState.dataset.timeout;
      if (timeout) clearTimeout(parseInt(timeout));
      const animEl = document.getElementById('drawingAnimation');
      animEl.classList.remove('slowing', 'stopping');
    }

    function launchConfetti() {
      const container = document.getElementById('confettiContainer');
      const colors = ['#ff0', '#f0f', '#0ff', '#f00', '#0f0', '#00f', '#ff6b35', '#ffd700'];

      // Create confetti pieces
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
        container.appendChild(confetti);

        // Trigger animation
        setTimeout(() => confetti.classList.add('active'), 10);

        // Clean up after animation
        setTimeout(() => confetti.remove(), 4000);
      }
    }

    function showWinner(winner) {
      const isNewWinner = currentWinnerTicketId !== winner.ticketId;

      sessionData.currentWinner = winner;
      winnerState.classList.remove('hidden');
      drawingState.classList.add('hidden');
      lockedState.classList.add('hidden');

      // Parse ticket ID
      const parts = winner.ticketId.split('-');
      document.getElementById('winnerBatchId').textContent = parts[0];
      document.getElementById('winnerTicketId').textContent = winner.ticketId;
      document.getElementById('winnerLabel').textContent = winner.batchLabel || '';

      // Only do animations for new winners
      if (isNewWinner) {
        currentWinnerTicketId = winner.ticketId;

        // Add reveal animation
        const winnerDisplay = document.getElementById('winnerDisplay');
        winnerDisplay.classList.add('winner-reveal', 'revealed');
        setTimeout(() => winnerDisplay.classList.remove('winner-reveal'), 600);

        // Start inactivity monitor for auto-hiding buttons
        startInactivityMonitor();
      }

      // Always update countdown
      startCountdown(winner.claimDeadline);
    }

    function startCountdown(deadline) {
      const countdownEl = document.getElementById('countdown');

      if (countdownInterval) clearInterval(countdownInterval);

      countdownInterval = setInterval(() => {
        const remaining = Math.max(0, Math.ceil((deadline - Date.now()) / 1000));
        countdownEl.textContent = remaining;

        if (remaining <= 10) {
          countdownEl.classList.add('urgent');
        } else {
          countdownEl.classList.remove('urgent');
        }

        if (remaining === 0) {
          clearInterval(countdownInterval);
        }
      }, 1000);
    }

    async function redraw() {
      const btn = document.getElementById('redrawBtn');
      btn.disabled = true;

      if (countdownInterval) clearInterval(countdownInterval);

      try {
        const response = await fetch(`/api/session/${currentSessionId}/redraw`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode: storedPasscode })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to redraw');
        }

        showWinner(data);
      } catch (err) {
        showError(err.message);
      } finally {
        btn.disabled = false;
      }
    }

    async function confirmClaim() {
      const btn = document.getElementById('confirmClaimBtn');
      btn.disabled = true;

      if (countdownInterval) clearInterval(countdownInterval);

      try {
        const response = await fetch(`/api/session/${currentSessionId}/confirm-claim`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode: storedPasscode })
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to confirm');
        }

        // Refresh session data
        const statusResponse = await fetch(`/api/session/${currentSessionId}`);
        sessionData = await statusResponse.json();

        sessionData.currentWinner = null;
        updateState();

      } catch (err) {
        showError(err.message);
      } finally {
        btn.disabled = false;
      }
    }

    async function closeSession() {
      if (!confirm('Are you sure you want to end this raffle?')) {
        return;
      }

      try {
        const response = await fetch(`/api/session/${currentSessionId}/close`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passcode: storedPasscode })
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to close');
        }

        sessionData.state = 'CLOSED';
        if (pollInterval) clearInterval(pollInterval);
        updateState();

      } catch (err) {
        showError(err.message);
      }
    }

    function showError(message) {
      errorDiv.textContent = message;
      errorDiv.classList.remove('hidden');
      setTimeout(() => {
        errorDiv.classList.add('hidden');
      }, 5000);
    }

    // Auto-hide winner action buttons after 5 seconds of inactivity
    // This runs independently of polling
    let lastActivityTime = Date.now();
    let inactivityCheckInterval = null;

    function startInactivityMonitor() {
      if (inactivityCheckInterval) return; // Already running

      lastActivityTime = Date.now();
      const actionsEl = document.getElementById('winnerActions');
      actionsEl.classList.remove('auto-hidden');

      // Check every 500ms if 5 seconds of inactivity has passed
      inactivityCheckInterval = setInterval(() => {
        if (winnerState.classList.contains('hidden')) {
          stopInactivityMonitor();
          return;
        }

        const elapsed = Date.now() - lastActivityTime;
        if (elapsed >= 5000) {
          actionsEl.classList.add('auto-hidden');
        }
      }, 500);
    }

    function stopInactivityMonitor() {
      if (inactivityCheckInterval) {
        clearInterval(inactivityCheckInterval);
        inactivityCheckInterval = null;
      }
    }

    function onUserActivity() {
      lastActivityTime = Date.now();

      // If winner state is visible, show the buttons
      if (!winnerState.classList.contains('hidden')) {
        const actionsEl = document.getElementById('winnerActions');
        actionsEl.classList.remove('auto-hidden');

        // Start monitor if not already running
        if (!inactivityCheckInterval) {
          startInactivityMonitor();
        }
      }
    }

    // Listen for user activity
    ['mousemove', 'mousedown', 'touchstart', 'keydown'].forEach(event => {
      document.addEventListener(event, onUserActivity);
    });
  </script>
</body>
</html>
